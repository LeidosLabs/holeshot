/*
 * Licensed to The Leidos Corporation under one or more contributor license agreements.
 * See the NOTICE file distributed with this work for additional information regarding copyright ownership.
 * The Leidos Corporation licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.leidoslabs.holeshot.ingest;

import java.awt.Dimension;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.renderable.ParameterBlock;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import javax.imageio.ImageIO;
import javax.media.jai.BorderExtender;
import javax.media.jai.Interpolation;
import javax.media.jai.JAI;
import javax.media.jai.PlanarImage;

import org.apache.commons.lang3.tuple.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.leidoslabs.holeshot.imaging.ImageKey;
import com.leidoslabs.holeshot.imaging.metadata.TilePyramidDescriptor;
import org.image.common.geojson.GeoJsonModule;

/**
 * Consolidates multiple partial image pyramids (such as those generated by each image part of a mosaic GeoTIFF as in
 * DGTiffTilePyramidBuilder) into a single full pyramid by generating the (lower resolution) higher r-sets from
 * the tiles of each sub-pyramid. At a minimum, the base rSet (rSet 0) must already be generated.
 */
public class MultiPartPyramidReducer {
   private static final Logger LOGGER = LoggerFactory.getLogger(MultiPartPyramidReducer.class);

   private TilePyramidDescriptor tilePyramidDescriptor;
   private Set<String> bucketList;
   private int startingRset;
   private boolean forceRegen;
   private final TilePyramidAccessor tilePyramidAccessor;
   private final TilePyramidListener tilePyramidListener;

    /**
     * Create a reducer that builds the entire pyramid above rSet 0, and reuses tiles if they already exist in storage.
     * @param tilePyramidAccessor The accessor for retrieving tiles
     * @param tilePyramidListener The publisher for saving tiles
     * @throws JsonParseException If the metadata for this tile pyramid can't be parsed
     * @throws JsonMappingException If the json metadata for this tile pyramid cant be mapped
     * @throws IOException If the metadata for this tile pyramid can't be opened and read
     */
   public MultiPartPyramidReducer(TilePyramidAccessor tilePyramidAccessor, TilePyramidListener tilePyramidListener) throws JsonParseException, JsonMappingException, IOException {
      this(tilePyramidAccessor, tilePyramidListener, -1, false);
   }

    /**
     * Create a reducer that builds the pyramid above the specified rSet. Any tiles that already exist above
     * startingRset will be regenerated. Any tiles at or below startingRset will be presumed to already exist
     * @param tilePyramidAccessor The accessor for retrieving tiles
     * @param tilePyramidListener The publisher for saving tiles
     * @param startingRset the top level of the existing partial tile pyramids to build upon
     * @throws JsonParseException If the metadata for this tile pyramid can't be parsed
     * @throws JsonMappingException If the json metadata for this tile pyramid cant be mapped
     * @throws IOException If the metadata for this tile pyramid can't be opened and read
     */
   public MultiPartPyramidReducer(TilePyramidAccessor tilePyramidAccessor, TilePyramidListener tilePyramidListener, int startingRset) throws JsonParseException, JsonMappingException, IOException {
      this(tilePyramidAccessor, tilePyramidListener, startingRset, true);
   }

    /**
     * Create a reducer that builds the pyramid above the specified rSet. Any tiles that already exist above
     * startingRset will be regenerated. Any tiles at or below startingRset will be presumed to already exist.
     * Optionally regenerate tiles above startingRset even if they are found to exist in storage.
     * @param tilePyramidAccessor The accessor for retrieving tiles
     * @param tilePyramidListener The publisher for saving tiles
     * @param startingRset the top level of the existing partial tile pyramids to build upon
     * @param forceRegen True if we should ignore already generated tiles above startingRset and recreated them instead
     * @throws JsonParseException If the metadata for this tile pyramid can't be parsed
     * @throws JsonMappingException If the json metadata for this tile pyramid cant be mapped
     * @throws IOException If the metadata for this tile pyramid can't be opened and read
     */
   public MultiPartPyramidReducer(TilePyramidAccessor tilePyramidAccessor, TilePyramidListener tilePyramidListener, int startingRset, boolean forceRegen)
         throws JsonParseException, JsonMappingException, IOException {
      this.tilePyramidAccessor = tilePyramidAccessor;
      this.tilePyramidListener = tilePyramidListener;
      this.startingRset = startingRset;
      this.forceRegen = forceRegen;

      populateBucketList();

      ObjectMapper objectMapper = new ObjectMapper();
      objectMapper.registerModule(new GeoJsonModule());

      try (InputStream is = tilePyramidAccessor.getMetadata()) {
         this.tilePyramidDescriptor = objectMapper.readValue(is, TilePyramidDescriptor.class);
      }
   }

   private void populateBucketList() throws IOException {
      if (!forceRegen) {
         bucketList = tilePyramidAccessor.listKeys();
      }
   }

   private void addToBucketList(String key) {
      if (!forceRegen) {
         bucketList.add(key);
      }
   }

    /**
     * Performs a series of steps to create a full image pyramid based on the tilePyramidDescriptor metadata. This
     * step would be performed after creating several partial tile pyramids, i.e. from processing a mosaic GeoTIFF with
     * 3 separate adjacent images, to complete the generation of the higher rSets which span these pyramids.
     * First, identifies which tiles will need to be generated to complete the image pyramid, creates the TileRequests,
     * and groups them by rSet, then orders the collections by ascending rSet value.
     * Next, calls the reduce function for each tile in an rSet group. Reduce will build and publish a tile generated
     * from the 4 tiles beneath it, thus as a rSet level finishes, the next higher level can proceed.
     */
   public void reduce() {
      IntStream.range(0,  getNumBands())
      .mapToObj(b->getTilesToBuild(new TileRequest(tilePyramidDescriptor.getMaxRLevel(), 0, 0, b)).stream())
      .flatMap(t->t)
      .collect(Collectors.groupingBy(t -> t.getRset())).entrySet().stream()
      .sorted((r1, r2) -> Integer.compare(r1.getKey(), r2.getKey()))
      .forEachOrdered(r -> r.getValue().parallelStream().forEach(t -> {
         try {
            reduce(t);
         } catch (Exception e) {
            e.printStackTrace();
         }
      }));
   }

   private AffineTransform getSubtileTransform(Point offset) {
      final double tileWidth = (double)tilePyramidDescriptor.getTileWidth();
      final double tileHeight = (double)tilePyramidDescriptor.getTileHeight();

      AffineTransform transform = new AffineTransform();
      transform.translate((offset.getX()) * tileWidth, (offset.getY()) * tileHeight);
      return transform;
   }

   private BufferedImage scaleImage(BufferedImage image, double scale) {
      ParameterBlock pb = new ParameterBlock();
      pb.add(image);
      PlanarImage im = (PlanarImage)JAI.create("awtImage", pb);

      ParameterBlock scaleParams = new ParameterBlock();
      scaleParams.addSource(im);
      scaleParams.add((float)scale).add((float)scale).add(0.0f).add(0.0f);
      scaleParams.add(Interpolation.getInstance(Interpolation.INTERP_BICUBIC_2));

      // Quality related hints when scaling the image
      RenderingHints scalingHints = new RenderingHints(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
      scalingHints.put(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
      scalingHints.put(JAI.KEY_BORDER_EXTENDER, BorderExtender.createInstance(BorderExtender.BORDER_COPY));
      scalingHints.put(JAI.KEY_TILE_CACHE, JAI.getDefaultInstance().getTileCache());
      return JAI.create("scale", scaleParams, scalingHints).getAsBufferedImage();
   }

   private BufferedImage createTileFromSubtiles(TileRequest tileRequest) throws IOException {
      BufferedImage result = null;
      List<Pair<Point, BufferedImage>> subimages = new ArrayList<Pair<Point, BufferedImage>>();
      for (int x = 0; x < 2; ++x) {
         for (int y = 0; y < 2; ++y) {
            TileRequest child = tileRequest.getChild(x, y);
            if (child != null) {
               BufferedImage image = child.read();
               if (image != null) {
                  subimages.add(Pair.of(new Point(x, y), image));
               }
            }
         }
      }

      if (!subimages.isEmpty()) {
         BufferedImage firstImage = subimages.get(0).getRight();
         BufferedImage mosaic = new BufferedImage(tilePyramidDescriptor.getTileWidth()*2,
               tilePyramidDescriptor.getTileHeight()*2, firstImage.getType());

         for (Pair<Point, BufferedImage> subimage : subimages) {
            AffineTransform transform = getSubtileTransform(subimage.getLeft());
            AffineTransformOp transformOp = new AffineTransformOp(transform, AffineTransformOp.TYPE_BICUBIC);
            transformOp.filter(subimage.getRight(), mosaic);
         }
         result = scaleImage(mosaic, 0.5);
      }
      return result;
   }


   private void reduce(TileRequest tileRequest) throws Exception {
      LOGGER.debug("reducing " + tileRequest.getKey());
      BufferedImage result = createTileFromSubtiles(tileRequest);
      if (result != null) {
         tilePyramidListener.handleTile(tilePyramidAccessor.getImageKey(),
               tileRequest.getBand(), tileRequest.getRset(), tileRequest.getCol(), tileRequest.getRow(), result);
         addToBucketList(tileRequest.getKey());
      }
   }


   private List<TileRequest> getTilesToBuild(TileRequest tileRequest) {
      return getTilesToBuild(tileRequest, new ArrayList<TileRequest>());
   }

   private List<TileRequest> getTilesToBuild(TileRequest tileRequest, List<TileRequest> tilesToBuild) {
      if ((forceRegen || !tileRequest.exists()) &&
            (startingRset<0 || tileRequest.getRset() > startingRset)) {
         tileRequest.createSubTiles().stream().forEach(t -> getTilesToBuild(t, tilesToBuild));

         LOGGER.debug("Adding " + tileRequest.getKey() + " to tilesToBuild");
         tilesToBuild.add(tileRequest);
      }
      return tilesToBuild;
   }

   @SuppressWarnings("unchecked")
   protected Map<String, Object> getMetadata() {
      return (Map<String, Object>) tilePyramidDescriptor.getMetadata();
   }

   private int getNumBands() {
      return Integer.parseInt(String.valueOf(getMetadata().get("NBANDS")));
   }

   private TileRequest createTileRequest(int rset, int col, int row, int band) {
      return new TileRequest(rset, col, row, band);
   }

   private class TileRequest {
      private final int rset;
      private final int row;
      private final int col;
      private final int band;
      private Dimension nextRsetRowCols;

      public TileRequest(int rset, int col, int row, int band) {
         this.rset = rset;
         this.col = col;
         this.row = row;
         this.band = band;
         this.nextRsetRowCols = getRowsAndColumnsForRset(this.rset - 1);
      }

      public int getRow() {
         return row;
      }

      public int getCol() {
         return col;
      }

      public int getBand() {
         return band;
      }

      public int getRset() {
         return this.rset;
      }

      public String getKey() {
         return tilePyramidAccessor.getTileKey(rset, col, row, band);
      }

      public boolean exists() {
         if (forceRegen) {
            throw new IllegalStateException("exists() should never be called when forceRegen is specified");
         }
         return bucketList.contains(getKey());
      }

       /**
        * Create a new list of TileRequests from this tile containing all immediate subtiles
        * @return An ArrayList of up to 4 TileRequests
        */
      public List<TileRequest> createSubTiles() {
         return createSubTiles(new ArrayList<TileRequest>());
      }

      private List<TileRequest> createSubTiles(List<TileRequest> subtiles) {
         for (int x=0;x<2;++x) {
            for (int y=0;y<2;++y) {
               TileRequest child = getChild(x,y);
               if (child != null) {
                  subtiles.add(child);
               }
            }
         }
         return subtiles;
      }

       /**
        * Get a TileRequest representing one of the child tiles for this tile. Generally called with 0 or 1 to retrieve
        * one of the 4 immediate subtiles of this tile in the tile pyramid
        * @param xOffset the column of this child tile relative to the upper left tile of the 4 immediate subtiles
        * @param yOffset the row of this child relative to the upper left tile of the 4 immediate subtiles
        * @return A TileRequest to retrieve the child tile data with, null if this tile has rSet 0
        */
      public TileRequest getChild(int xOffset, int yOffset) {
         TileRequest child = null;
         if (this.rset > 0) {
            final int x = xOffset + col * 2;
            final int y = yOffset + row * 2;
            if (x < nextRsetRowCols.getWidth() && y < nextRsetRowCols.getHeight()) {
               child = new TileRequest(this.rset - 1, x, y, band);
            }
         }
         return child;
      }

       /**
        * Use the defined tilePyramidAccessor to read this tile data into memory.
        * @return BufferedImage of this tile, may be null if image is not in the tile bucketList and forceRegen is false
        * @throws IOException if getTile fails or reading the input stream it returns fails
        */
      public BufferedImage read() throws IOException {
         BufferedImage image = null;

         final String key = getKey();
         if (forceRegen || exists()) {

            try (InputStream is = tilePyramidAccessor.getTile(rset, col, row, band)) {
               if (is != null) {
                  image = ImageIO.read(is);

                  // Without this, S3AbortableInputStream will report, "Not all bytes were read from the S3ObjectInputStream"
                  is.skip(Long.MAX_VALUE);
               }
            }
         }

         if (image == null) {
            LOGGER.warn(String.format("%s - Input Object doesn't exist", key));
         }
         return image;
      }

      private Dimension getRowsAndColumnsForRset(int rset) {
         Dimension result = null;
         if (rset >= 0) {
            final double rsetFactor = Math.pow(2.0, rset);
            result = new Dimension(
                  (int) Math.ceil(tilePyramidDescriptor.getWidth() / (rsetFactor * tilePyramidDescriptor.getTileWidth())),
                  (int) Math
                  .ceil(tilePyramidDescriptor.getHeight() / (rsetFactor * tilePyramidDescriptor.getTileHeight())));
         }
         return result;
      }
   }

    /**
     * For testing purposes
     * @param args
     */
   public static void main(String[] args) {
      try {
         final String bucketName = "advanced-analytics-geo-tile-images";
         final ZonedDateTime nowUTC = ZonedDateTime.now(ZoneOffset.UTC);
         final TilePyramidAccessor tilePyramidAccessor = new S3TilePyramidAccessor(bucketName, new ImageKey("058618316010_01_P001", nowUTC, nowUTC));
         final TilePyramidListener tilePyramidListener = new S3TileListener(bucketName, null);
         final MultiPartPyramidReducer reducer =
               new MultiPartPyramidReducer(tilePyramidAccessor, tilePyramidListener, 5, true);

         final boolean testSingleImage = false;
         if (testSingleImage) {
            TileRequest tileRequest = reducer.createTileRequest(4,2,2,0);
            BufferedImage image = reducer.createTileFromSubtiles(tileRequest);

            ImageIO.write(image,  "png",  new File("F:/mosaic.png"));
         } else {
            reducer.reduce();
         }
      } catch (Exception e) {
         e.printStackTrace();
      }
   }



}
